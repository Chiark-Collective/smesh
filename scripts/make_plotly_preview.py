"""Generate an interactive Plotly preview combining mesh + sample point clouds.

The script expects the demo assets generated by the example configs under
``examples/outputs``. It builds an interactive HTML file that can be opened in a
browser (and optionally a static PNG when Kaleido is available).
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable, List, Tuple

import numpy as np

from smesh.core.scene import MeshScene


def _default_repo_root() -> Path:
    return Path(__file__).resolve().parents[1]


def _load_mesh(mesh_path: Path) -> Tuple[np.ndarray, np.ndarray]:
    scene = MeshScene(mesh_path)
    verts, faces = scene.triangle_arrays()
    return verts.astype(np.float32, copy=False), faces.astype(np.int32, copy=False)


def _load_point_cloud(path: Path) -> np.ndarray:
    ext = path.suffix.lower()
    if ext in {".las", ".laz"}:
        try:
            import laspy
        except ImportError as exc:  # pragma: no cover - requires optional dep at runtime
            raise RuntimeError("laspy is required to read LAS/LAZ point clouds.") from exc
        with laspy.open(path) as reader:
            pts = reader.read()
            xyz = np.vstack((pts.x, pts.y, pts.z)).T
            return xyz.astype(np.float32, copy=False)
    if ext == ".npz":
        cloud = np.load(path)
        if "xyz" not in cloud:
            raise RuntimeError(f"{path} does not contain an 'xyz' array.")
        return cloud["xyz"].astype(np.float32, copy=False)
    raise RuntimeError(f"Unsupported point cloud extension '{ext}'.")


def _downsample(xyz: np.ndarray, max_points: int, rng: np.random.Generator) -> np.ndarray:
    if xyz.shape[0] <= max_points:
        return xyz
    idx = rng.choice(xyz.shape[0], size=max_points, replace=False)
    return xyz[idx]


def _mesh_components(
    vertices: np.ndarray, faces: np.ndarray
) -> List[Tuple[np.ndarray, np.ndarray, float]]:
    """Split a mesh into connected components, returning (verts, faces, avg_height)."""
    face_count = faces.shape[0]
    adjacency: List[List[int]] = [[] for _ in range(face_count)]
    edge_map: dict[Tuple[int, int], List[int]] = {}
    for face_idx, tri in enumerate(faces):
        for edge in ((tri[0], tri[1]), (tri[1], tri[2]), (tri[2], tri[0])):
            a, b = sorted(edge)
            edge_map.setdefault((a, b), []).append(face_idx)
    for idxs in edge_map.values():
        if len(idxs) < 2:
            continue
        for i in range(len(idxs)):
            for j in range(i + 1, len(idxs)):
                a, b = idxs[i], idxs[j]
                adjacency[a].append(b)
                adjacency[b].append(a)

    components: List[List[int]] = []
    visited = [-1] * face_count
    for start in range(face_count):
        if visited[start] != -1:
            continue
        stack = [start]
        visited[start] = len(components)
        comp_faces: List[int] = []
        while stack:
            cur = stack.pop()
            comp_faces.append(cur)
            for nxt in adjacency[cur]:
                if visited[nxt] == -1:
                    visited[nxt] = len(components)
                    stack.append(nxt)
        components.append(comp_faces)

    result: List[Tuple[np.ndarray, np.ndarray, float]] = []
    for comp in components:
        comp_faces = faces[np.asarray(comp)]
        unique_vertices = np.unique(comp_faces)
        index_map = {old_idx: new_idx for new_idx, old_idx in enumerate(unique_vertices.tolist())}
        remapped_faces = np.vectorize(index_map.get)(comp_faces)
        sub_vertices = vertices[unique_vertices]
        avg_height = float(sub_vertices[:, 2].mean())
        result.append((sub_vertices, remapped_faces.astype(np.int32, copy=False), avg_height))
    return result


def _build_figure(
    mesh_vertices: np.ndarray,
    mesh_faces: np.ndarray,
    samples: Iterable[Tuple[str, np.ndarray, str]],
) -> "plotly.graph_objects.Figure":
    try:
        import plotly.graph_objects as go
    except ImportError as exc:  # pragma: no cover - import-time guard
        raise RuntimeError("plotly is required to build the interactive figure.") from exc

    fig = go.Figure()

    mesh_components = _mesh_components(mesh_vertices, mesh_faces)
    pastel_palette = ["#C7E9C0", "#FFF2B2", "#D4C5F9", "#FCD5D8"]
    component_labels = ["Ground", "Ramp", "Tower", "Detail"]
    mesh_components.sort(key=lambda item: item[2])  # sort by height

    ground_bounds = (
        float(mesh_vertices[:, 0].min()),
        float(mesh_vertices[:, 0].max()),
        float(mesh_vertices[:, 1].min()),
        float(mesh_vertices[:, 1].max()),
    )
    ramp_patch_bounds: Tuple[float, float, float, float] | None = None
    ground_color = pastel_palette[0]

    for idx, (verts, faces, avg_height) in enumerate(mesh_components):
        color = pastel_palette[idx % len(pastel_palette)]
        label = component_labels[idx] if idx < len(component_labels) else f"Mesh Part {idx+1}"
        opacity = 1.0
        fig.add_trace(
            go.Mesh3d(
                x=verts[:, 0],
                y=verts[:, 1],
                z=verts[:, 2],
                i=faces[:, 0],
                j=faces[:, 1],
                k=faces[:, 2],
                color=color,
                opacity=opacity,
                name=label,
                showscale=False,
            )
        )
        if 0.05 <= avg_height <= 3.5:
            pad_x = 0.4
            pad_y = 0.4
            x_min, y_min = verts[:, 0].min() - pad_x, verts[:, 1].min() - pad_y
            x_max, y_max = verts[:, 0].max() + pad_x, verts[:, 1].max() + pad_y
            ramp_patch_bounds = (x_min, x_max, y_min, y_max)

    if ground_bounds is not None:
        x_min, x_max, y_min, y_max = ground_bounds
        floor_plane_vertices = np.array(
            [
                [x_min, y_min, -0.05],
                [x_max, y_min, -0.05],
                [x_max, y_max, -0.05],
                [x_min, y_max, -0.05],
            ],
            dtype=np.float32,
        )
        floor_plane_faces = np.array([[0, 1, 2], [0, 2, 3]], dtype=np.int32)
        fig.add_trace(
            go.Mesh3d(
                x=floor_plane_vertices[:, 0],
                y=floor_plane_vertices[:, 1],
                z=floor_plane_vertices[:, 2],
                i=floor_plane_faces[:, 0],
                j=floor_plane_faces[:, 1],
                k=floor_plane_faces[:, 2],
                color=ground_color,
                opacity=0.25,
                name="Ground Fill",
                showscale=False,
            )
        )

    if ramp_patch_bounds is not None:
        x_min, x_max, y_min, y_max = ramp_patch_bounds
        base_pad = 0.8
        x_min = max(x_min - base_pad, ground_bounds[0])
        x_max = min(x_max + base_pad, ground_bounds[1])
        y_min = max(y_min - base_pad, ground_bounds[2])
        y_max = min(y_max + base_pad, ground_bounds[3])
        ramp_plane_vertices = np.array(
            [
                [x_min, y_min, -0.02],
                [x_max, y_min, -0.02],
                [x_max, y_max, -0.02],
                [x_min, y_max, -0.02],
            ],
            dtype=np.float32,
        )
        ramp_plane_faces = np.array([[0, 1, 2], [0, 2, 3]], dtype=np.int32)
        fig.add_trace(
            go.Mesh3d(
                x=ramp_plane_vertices[:, 0],
                y=ramp_plane_vertices[:, 1],
                z=ramp_plane_vertices[:, 2],
                i=ramp_plane_faces[:, 0],
                j=ramp_plane_faces[:, 1],
                k=ramp_plane_faces[:, 2],
                color=ground_color,
                opacity=0.2,
                name="Ground Fill",
                showscale=False,
            )
        )

    size_lookup = {
        "Aerial LiDAR": 2.0,
        "Mobile LiDAR": 2.0,
        "Photogrammetry": 4.5,
        "Total Station": 2.5,
    }
    for label, xyz, color in samples:
        marker_size = size_lookup.get(label, 2.0)
        fig.add_trace(
            go.Scatter3d(
                x=xyz[:, 0],
                y=xyz[:, 1],
                z=xyz[:, 2],
                mode="markers",
                name=label,
                marker=dict(size=marker_size, color=color, opacity=0.95),
            )
        )

    fig.update_layout(
        scene=dict(
            xaxis=dict(title="X", showgrid=False),
            yaxis=dict(title="Y", showgrid=False),
            zaxis=dict(title="Z", showgrid=False),
            aspectmode="data",
        ),
        legend=dict(itemsizing="constant"),
        margin=dict(l=0, r=0, t=30, b=0),
        title="Smesh Sensor Preview",
    )
    return fig


def main() -> None:
    root = _default_repo_root()
    default_mesh = root / "examples/meshes/preview_scene.ply"
    default_outputs = [
        ("Aerial LiDAR", root / "examples/outputs/aerial_lidar.las", "#1F77B4"),
        ("Mobile LiDAR", root / "examples/outputs/mobile_lidar.las", "#FF7F0E"),
        ("Photogrammetry", root / "examples/outputs/photogrammetry.npz", "#2CA02C"),
        ("Total Station", root / "examples/outputs/total_station.npz", "#D62728"),
    ]

    parser = argparse.ArgumentParser(description="Generate Plotly preview for README.")
    parser.add_argument("--mesh", type=Path, default=default_mesh, help="Mesh to render.")
    parser.add_argument(
        "--cloud",
        nargs=2,
        action="append",
        metavar=("LABEL", "PATH"),
        help="Override/add a point cloud (label path). Can be repeated.",
    )
    parser.add_argument(
        "--output-html",
        type=Path,
        default=root / "examples/images/readme_preview.html",
        help="Where to save the interactive HTML.",
    )
    parser.add_argument(
        "--output-png",
        type=Path,
        default=root / "examples/images/readme_preview.png",
        help="Optional static preview (requires kaleido).",
    )
    parser.add_argument(
        "--max-points",
        type=int,
        default=40_000,
        help="Maximum points per cloud before random downsampling.",
    )
    parser.add_argument("--seed", type=int, default=7, help="Random seed for downsampling.")
    args = parser.parse_args()

    if args.cloud:
        clouds = []
        for label, path_str in args.cloud:
            clouds.append((label, Path(path_str)))
    else:
        clouds = [(label, path) for label, path, _ in default_outputs]

    color_lookup = {label: color for label, _, color in default_outputs}
    rng = np.random.default_rng(args.seed)

    mesh_vertices, mesh_faces = _load_mesh(args.mesh)

    samples_for_plot = []
    for label, cloud_path in clouds:
        color = color_lookup.get(label, "#666666")
        xyz = _load_point_cloud(cloud_path)
        xyz = _downsample(xyz, args.max_points, rng)
        samples_for_plot.append((label, xyz, color))

    fig = _build_figure(mesh_vertices, mesh_faces, samples_for_plot)
    args.output_html.parent.mkdir(parents=True, exist_ok=True)
    fig.write_html(args.output_html, include_plotlyjs="cdn", full_html=True)

    if args.output_png:
        try:
            import plotly.io as pio

            fig.write_image(args.output_png, width=1400, height=900, scale=1.5)
        except Exception as exc:  # pragma: no cover - optional dependency
            print(f"[WARN] Could not write PNG preview: {exc}")


if __name__ == "__main__":
    main()
